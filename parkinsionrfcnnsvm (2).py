# -*- coding: utf-8 -*-
"""parkinsionRfCnnSvm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cKSBunipHFgsjtt9696HxLjVI2gS-k8R
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, mean_absolute_error, mean_squared_error
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.optimizers import Adam
from sklearn.base import BaseEstimator, ClassifierMixin

# Read the dataset
df = pd.read_csv("parkinsons.csv")

df.head()

df.isnull().sum()

# Extract features (dropping 'name' and 'status') and target ('status')
features = df.drop(['name', 'status'], axis=1)
target = df['status']

# Scale features between -1 and 1
scaler = MinMaxScaler((-1, 1))
features_scaled = scaler.fit_transform(features)

# Split the dataset into training and testing sets (80/20)
x_train, x_test, y_train, y_test = train_test_split(features_scaled, target, test_size=0.3, random_state=10)

x_train.shape

# Define the CNN model
def build_cnn(input_dim):
    model = Sequential([
        Dense(128, activation='relu', input_dim=input_dim),
        Dropout(0.3),
        Dense(64, activation='relu'),
        Dropout(0.3),
        Dense(1, activation='sigmoid')
    ])
    model.compile(optimizer=Adam(learning_rate=0.001), loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Train the CNN model
cnn_model = build_cnn(x_train.shape[1])
cnn_model.fit(x_train, y_train, epochs=50, batch_size=16, verbose=0, validation_split=0.1)

# Define the SVM model
svm_model = SVC(probability=True, kernel='rbf', random_state=10)
svm_model.fit(x_train, y_train)

# Define the Random Forest model
rf_model = RandomForestClassifier(random_state=2)
rf_model.fit(x_train, y_train)

# Ensemble voting classifier
class EnsembleModel(BaseEstimator, ClassifierMixin):
    def __init__(self, rf, svm, cnn):
        self.rf = rf
        self.svm = svm
        self.cnn = cnn

    def predict_proba(self, X):
        # Get probabilities from all models
        rf_prob = self.rf.predict_proba(X)[:, 1]
        svm_prob = self.svm.predict_proba(X)[:, 1]
        cnn_prob = self.cnn.predict(X).flatten()

        # Average the probabilities
        avg_prob = (rf_prob + svm_prob + cnn_prob) / 3
        return np.vstack([1 - avg_prob, avg_prob]).T

    def predict(self, X):
        return (self.predict_proba(X)[:, 1] > 0.5).astype(int)

# Initialize the ensemble model
ensemble_model = EnsembleModel(rf=rf_model, svm=svm_model, cnn=cnn_model)

# Predict using the ensemble model
y_pred = ensemble_model.predict(x_test)

# Calculate metrics
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Mean Absolute Error:", mean_absolute_error(y_test, y_pred))
print("Root Mean Squared Error:", np.sqrt(mean_squared_error(y_test, y_pred)))

for i in range(3):
    in_data = np.asarray(tuple(map(float, input("Enter the data:").rstrip().split(','))))  # Ensure there are 22 features
    if len(in_data) != 22:
        print("Invalid input! Please enter exactly 22 features.")
        continue
    in_data_re = in_data.reshape(1, -1)
    in_data_sca = scaler.transform(in_data_re)

    # Predict using the ensemble model
    prediction = ensemble_model.predict(in_data_sca)
    print("Parkinson's Disease Detected\n" if prediction else "No Parkinson's Disease Detected\n")

  # sample Imput: 1,150,0.1,0.4,0.2,0.6,0.4,0.3,0.2,0.7,0.5,0.3,0.4,0.3,0.2,0.6,0.4,0.1,0.3,0.2,0.5,0.1